

# 一、构建后端维护目录

> 自定义后端: `diy`。

```bash
- package/
	- __init__.py
	- deploymodel.py
	- backends.py
	- base_option.py
	- diy/ # 自定义后端接口维护目录
		- __init__.py # 引出创建模型推理接口等的公共接口
		- models.py # 注册模型推理接口
		- utils.py # 实现创建模型推理接口的公共接口以及注册推理接口的函数
```

----

# 二、完善`__init__.py`

```python
# 引出后端的推理接口创建函数、配置项创建函数和推理结果处理函数供外部调用
from package.diy.utils import create_diy_inference_api, create_diy_option, process_diy_predict_result

# 导入后端的models完成后端推理接口的注册
import package.diy.models
```

----

# 三、完善`utils.py`

> `diy_backend`为自定义后端的本体实现。

```python
import os, sys
import json

# 如有需要可导入自定义后端的主体
import diy_backend

# 导入基本配置项，用于构建特定后端的配置项
from package.base_option import InferOption

__all__ = [
    "register_inference_api",
    "find_inference_api",
    "create_diy_inference_api",
    "create_diy_option",
    "process_diy_predict_result"
]

# 特定后端已注册接口采用字典接口进行缓存: {"cls": {"mobilenetv1": api1, "shullfulnetv2": api2}, "det": {}, "seg": {}}
DIY_INFERENCE_APIS = {}
def register_inference_api(
        model_type: str,
        model_name: str,
        infer_api
    ):
    """注册推理接口
        1. model_type用于第一级注册分类
        2. model_name用于第二级注册分类
        3. infer_api为具体的接口实现(class)
    """
    # 导入全局变量
    global DIY_INFERENCE_APIS
    if model_type not in DIY_INFERENCE_APIS.keys():
        DIY_INFERENCE_APIS[model_type] = {}
    if model_name not in DIY_INFERENCE_APIS[model_type].keys(): # 运行时注册API
        DIY_INFERENCE_APIS[model_type][model_name] = infer_api
    else:
        raise ValueError("({0} - register_inference_api) Model API({1}-{2}) has created, it should not registe repeatly.".format(
                    os.path.abspath(__file__), model_type, model_name))

def find_inference_api(
        model_type: str,
        model_name: str
    ):
    """查询已注册接口并返回接口
        1.model_type选定特定类型下的接口集合
        2.model_name选定指定模型的接口
    """
    if model_type in DIY_INFERENCE_APIS.keys() and model_name in DIY_INFERENCE_APIS[model_type].keys():
        return DIY_INFERENCE_APIS[model_type][model_name]
    else:
        raise ValueError("({0} - find_inference_api) Model API({1}-{2}) don't find.".format(
                os.path.abspath(__file__), model_type, model_name))

def create_diy_inference_api(
        model_type: str,
        model_name: str
    ):
    """创建DIY的推理接口——统一接口
    """
    _api = None
    _api = find_inference_api(model_type, model_name)
    return _api

def create_diy_option(
        model_path: str,
        params_path: str,
        config_path: str,
        deploy_device: str
    ):
    """构建DIY后端推理的配置项——统一接口
    """
    _infer_option = InferOption()
    _infer_option.name = "diy_backend"
    _infer_option.model_path = model_path
    _infer_option.params_path = params_path
    _infer_option.config_path = config_path
    _infer_option.deploy_device = deploy_device
    _infer_option.runtime_option = None
    
    # 其它配置项
    # ...

    _infer_option.check_file_is_exists()
    return _infer_option

def process_diy_predict_result(
        result,
        model_type: str,
        **kwargs
    ):
    """解析DIY后端推理结果为Json格式——统一接口
        1. 针对det检测模型结果进行阈值处理
        2. kwargs直接传入即可——默认处理threshold
    """
    _result = None
    # 1. 推理结果与kwargs参数进行匹配，比如检测目标的阈值筛选
    # 2. 获取推理结果的Json格式
    return _result

```

----

# 四、完善`models.py`

```python
import diy_backend

# 导入模型推理结构注册函数
from package.diy.utils import register_inference_api


# 分类模型推理接口注册
register_inference_api("cls", "mobilenetv1", diy_backend.xxxx_api1)

# 检测模型推理接口注册
register_inference_api("det", "yolov5", diy_backend.xxxx_api2)

# 分割模型推理接口注册
register_inference_api("seg", "unet", diy_backend.xxxx_api2)

print("register finished.")
```

> `diy_backend.xxxx_api1`接口应为接口类，提供`predict`预测接口——且接口类实例时保持一致的入口参数！！！

